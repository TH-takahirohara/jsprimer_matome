# 関数とスコープ

## クロージャー
- クロージャーは、「外側のスコープにある変数への参照を保持できる」という関数が持つ性質のこと。
- 静的スコープ、メモリ管理の仕組みについての理解が必要。

### 静的スコープ
- どの識別子がどの変数を参照しているかを静的に決定する性質を静的スコープと呼ぶ。
- JavaScriptは静的スコープ。

### 動的スコープ
- 呼び出し元のスコープの変数を参照する仕組みを動的スコープという。
- JavaScriptでもthisという特別なキーワードだけは、呼び出し元によって動的に参照先が変わる。

### メモリ管理の仕組み
- 参照されなくなったデータを開放するメモリ管理の仕組みとしてガベージコレクションがある。
- JavaScriptでは、メモリ管理としてガベージコレクションが採用されている。
- よく誤解されるが、関数の中で作成したデータは、その関数の実行が終了した時点で必ずしも解放されるわけではない。
    - 例：　内部で変数aを定義し、その変数aを戻り値とする関数bがあるとする。関数bの呼び出しを別の変数xに代入した場合、aが参照する値はxからも参照され続けるため、データが自動的に開放されることはない。
- そのデータがメモリ上から開放されるかどうかは、そのデータが参照されているかによって決定されるのである。

### クロージャーがなぜ動くのか
クロージャーは、下記2つの仕組みを利用して、関数内から特定の変数を参照し続けることで関数が状態を持てる仕組みのことを言う。
- 静的スコープ: ある変数がどの値を参照するかは静的に決まる
- メモリ管理の仕組み: 参照されなくなったデータはガベージコレクションにより解放される

### クロージャーの用途
クロージャーはさまざまな用途に利用されますが、次のような用途で利用されることが多い。
- 関数に状態を持たせる手段として
- 外から参照できない変数を定義する手段として
- グローバル変数を減らす手段として
- 高階関数の一部部分として

## まとめ
- 関数やブロックはスコープを持つ
- スコープはネストできる
- もっとも外側にはグローバルスコープがある
- スコープチェーンは内側から外側のスコープへと順番に変数が定義されているか探す仕組みのこと
- varキーワードでの変数宣言やfunctionでの関数宣言では巻き上げが発生する
- クロージャーは静的スコープとメモリ管理の仕組みからなる関数が持つ性質

# 関数とthis
https://jsprimer.net/basic/function-this/

- thisキーワードは基本的にはメソッドの中で利用するが、読み取り専用のグローバル変数のようなものでどこにでもかける。
- thisの参照先は主に次の条件によって変化する。
  - 実行コンテキストにおけるthis
  - コンストラクタにおけるthis
  - 関数とメソッドにおけるthis
  - Arrow Functionにおけるthis

## 実行コンテキストとthis

### スクリプトにおけるthis
- 実行コンテキストが"Script"である場合、トップレベルのスコープに書かれたthisはグローバルオブジェクトを参照します。
  - ブラウザのグローバルオブジェクトはwindowオブジェクト

 ### モジュールにおけるthis
- 実行コンテキストが"Module"である場合、そのトップレベルのスコープに書かれたthisは常にundefinedとなります。

## 関数とメソッドにおけるthis
- thisが参照先を決めるルールは、Arrow Functionとそれ以外の関数定義の方法で異なります。

### 関数の種類
```
// `function`キーワードからはじめる関数宣言
function fn1() {}
// `function`を式として扱う関数式
const fn2 = function() {};
// Arrow Functionを使った関数式
const fn3 = () => {};
```

### メソッドの種類
- JavaScriptではオブジェクトのプロパティが関数である場合にそれをメソッドと呼びます。

|  名前  |  関数  |  メソッド  |
| ---- | ---- | ---- |
|  関数宣言(function fn(){})  |  ○  |  ×  |
|  関数式(const fn = function(){})  |  ○  |  ○  |
|  Arrow Function(const fn = () => {})  |  ○  |  ○  |
|  メソッドの短縮記法(const obj = { method(){} })  |  ×  |  ○  |

## Arrow Function以外の関数におけるthis
- Arrow Function以外の関数（メソッドも含む）におけるthisは、実行時に決まる値となります。 言い方を変えるとthisは関数に渡される暗黙的な引数のようなもので、その渡される値は関数を実行するときに決まります。
- 関数におけるthisの基本的な参照先（暗黙的に関数に渡すthisの値）はベースオブジェクトとなります。 ベースオブジェクトとは「メソッドを呼ぶ際に、そのメソッドのドット演算子またはブラケット演算子のひとつ左にあるオブジェクト」のことを言います。
  - ベースオブジェクトがない場合のthisはundefinedとなります。
- thisは関数の定義ではなく呼び出し方で参照する値が異なるので注意

### 関数宣言や関数式におけるthis
- メソッド以外でthisを使う必要はない。

### メソッド呼び出しにおけるthis
- メソッドの場合は、そのメソッドが何かしらのオブジェクトに所属しています。ベースオブジェクトとして、その所属するオブジェクトが取得できます。

## thisが問題となるパターン
- thisには、どの値を参照するかは関数の呼び出し時に決まるという性質に由来したいろいろな問題がある。

### 問題：thisを含むメソッドを変数に代入した場合
- メソッドとして定義した関数も、別の変数に代入すると実行時にはただの関数であるためベースオブジェクトが変わってしまっている。
- 対処法は大きく分けて2つある。
  - メソッドとして定義されている関数はメソッドとして呼ぶと言うこと
  - thisの値を指定して関数を呼べるメソッドで関数を実行する方法（下記対処法参照）
- 基本的には前者のやり方で問題を回避し、どうしてもthisを固定したい場合には後者の方法を取るのが良い。

#### 対処法: call、apply、bindメソッド
- callメソッド
`関数.call(thisの値, ...関数の引数);`

- applyメソッド
`関数.apply(thisの値, [関数の引数1, 関数の引数2]);`

- bindメソッド
`関数.bind(thisの値, ...関数の引数); // => thisや引数がbindされた関数`

### 問題：コールバック関数とthis
- コールバック関数の中でthisを参照すると問題となる場合があります。
- この問題は、メソッドの中でArray#mapメソッドなどのコールバック関数を扱う場合に発生しやすいです。
- Array#mapメソッドに渡しているコールバック関数はcallback()のようにただの関数として呼び出されるため、callback関数のthisはundefinedとなる。

#### 対処法: thisを一時変数へ代入する

#### 対処法: Arrow Functionでコールバック関数を扱う
- Arrow Functionは呼び出し時に暗黙的なthisの値を受け取りません。そのためArrow Function内のthisは、スコープチェーンの仕組みと同様に外側の関数を探索します。これにより、Arrow Functionで定義したコールバック関数は呼び出し方には関係なく、常に外側の関数のthisをそのまま利用します。

## Arrow Functionとthis
- Arrow Functionとそれ以外の関数で大きく違うことは、Arrow Functionはthisを暗黙的な引数として受けつけないということです。
- そのため、Arrow Function内にはthisが定義されていません。このときのthisは外側のスコープ（関数）のthisを参照します。これは、変数におけるスコープチェーンの仕組みと同様で、そのスコープにthisが定義されていない場合には外側のスコープを探索します。
- Arrow Functionにおけるthisは、「Arrow Function自身の外側のスコープに定義されたもっとも近い関数のthisの値」となる。

### メソッドとコールバック関数とArrow Function
- Arrow Functionにおけるthisは呼び出し方の影響を受けません。 つまり、コールバック関数がどのように呼ばれるかという実装についてを考えることなくthisを扱えます。

### Arrow Functionはthisをbindできない
- Arrow Functionで定義した関数ではcall、apply、bindを使ったthisの指定は単に無視されます。 これは、Arrow Functionはthisを持てないためです。

## まとめ
-  メソッド以外においてもthisは評価できますが、実行コンテキストやstrict modeなどによって結果が異なり、混乱の元となります。 そのため、メソッドではない通常の関数においてはthisを使うべきではありません。
- コールバック関数におけるthisはArrow Functionを使うことでわかりやすく解決できます。

# クラス
- クラスとは動作や状態を定義した構造である。 クラスからはインスタンスと呼ばれるオブジェクトを作成できる。インスタンスはクラスに定義した動作を継承し、状態は動作によって変化する。

## クラスの定義
- クラスを定義するにはclass構文を使います。 クラスの定義方法にはクラス宣言文とクラス式があります。

- クラス宣言文によるクラスの定義方法
```
class MyClass {
    constructor() {
        // コンストラクタ関数の処理
        // インスタンス化されるときに自動的に呼び出される
    }
}
```

- クラス式による定義方法。クラスを値として定義する。クラス式ではクラス名を省略できる。
```
const MyClass = class MyClass {
    constructor() {}
};

const AnonymousClass = class {
    constructor() {}
};
```

## クラスのインスタンス化
- クラスはnew演算子でインスタンスであるオブジェクトを作成できます。
```
class MyClass {
}
// `MyClass`をインスタンス化する
const myClass = new MyClass();
// 毎回新しいインスタンス(オブジェクト)を作成する
const myClassAnother = new MyClass();
// それぞれのインスタンスは異なるオブジェクト
console.log(myClass === myClassAnother); // => false
// クラスのインスタンスかどうかは`instanceof`演算子で判定できる
console.log(myClass instanceof MyClass); // => true
console.log(myClassAnother instanceof MyClass); // => true
```

- クラスではインスタンスの初期化処理をコンストラクタ関数で行います。 コンストラクタ関数はnew演算子でインスタンス化する際に自動的に呼び出されます。 コンストラクタ関数内でのthisはこれから新しく作るインスタンスオブジェクトとなります。

```
class Point {
    // 2. コンストラクタ関数の仮引数として`x`には`3`、`y`には`4`が渡る
    constructor(x, y) {
        // 3. インスタンス(`this`)の`x`と`y`プロパティにそれぞれ値を設定する
        this.x = x;
        this.y = y;
        // コンストラクタではreturn文は書かない
    }
}

// 1. コンストラクタを`new`演算子で引数とともに呼び出す
const point = new Point(3, 4);
// 4. `Point`のインスタンスである`point`の`x`と`y`プロパティには初期化された値が入る
console.log(point.x); // => 3
console.log(point.y); // => 4
```

- コンストラクタは初期化処理を書く場所であるため、return文で値を返すべきではありません。
- クラス名は大文字ではじめる

## [コラム] class構文と関数でのクラスの違い
- 関数でクラスのようなものを実装した場合には、関数として呼び出せてしまう問題があります。 

## クラスのプロトタイプメソッドの定義
- class構文ではクラスに対してメソッドを定義できます。メソッドの中からクラスのインスタンスを参照するには、constructorメソッドと同じくthisを使います。
```
class クラス {
    メソッド() {
        // ここでの`this`はベースオブジェクトを参照
    }
}

const インスタンス = new クラス();
// メソッド呼び出しのベースオブジェクト(`this`)は`インスタンス`となる
インスタンス.メソッド();
```

- このようにクラスに対して定義したメソッドは、クラスの各インスタンスから共有されるメソッドとなります。 このインスタンス間で共有されるメソッドのことをプロトタイプメソッドと呼びます。 また、プロトタイプメソッドはインスタンスから呼び出せるメソッドであるためインスタンスメソッドとも呼ばれます。
- プロトタイプメソッドは各インスタンス間で共有されるので、参照先は同じになる。

## クラスのインスタンスに対してメソッドを定義する
- クラスのインスタンスに対して、直接メソッドを定義する方法もあります。これは、コンストラクタ関数内でインスタンスオブジェクトであるthisに対してメソッドを定義するだけです。
- この場合、プロトタイプメソッドとは異なり、インスタンス作成時に毎回関数を新しく定義しているので、各インスタンスからのメソッドの参照先は異なる。（プロトタイプメソッドではメソッドの参照先は同じだった。）
- また、プロトタイプメソッドとは異なり、インスタンスオブジェクトへのメソッド定義はArrow Functionが利用できます。この場合、メソッド内のthisの参照先を固定化できる。

## クラスのアクセッサプロパティの定義
```
class クラス {
    // getter
    get プロパティ名() {
        return 値;
    }
    // setter
    set プロパティ名(仮引数) {
        // setterの処理
    }
}
const インスタンス = new クラス();
インスタンス.プロパティ名; // getterが呼び出される
インスタンス.プロパティ名 = 値; // setterが呼び出される
```

- アクセッサプロパティで実際に読み書きしているプロパティを`_value`などと`_`で開始する習慣がある。構文としての意味はない。

## 静的メソッド
- クラスをインスタンス化せずに利用できる静的メソッド（クラスメソッド）もあります。
- 静的メソッドの定義方法はメソッド名の前に、staticをつけるだけです。

```
class クラス {
    static メソッド() {
        // 静的メソッドの処理
    }
}
// 静的メソッドの呼び出し
クラス.メソッド();
```

- クラスの静的メソッドにおけるthisは、そのクラス自身を参照します。
- 静的メソッドは、クラスのインスタンスを作成する処理やクラスに関係する処理を書くために利用されます。

## 2種類のインスタンスメソッドの定義
- プロトタイプメソッドの定義と、 インスタンスオブジェクトに対するメソッドの定義を同時に使い、1つのクラスに同じ名前でメソッドを2つ定義した場合、下記のようになる。
  - プロトタイプメソッドとインスタンスオブジェクトのメソッドは上書きされずにどちらも定義されている
  - インスタンスオブジェクトのメソッドがプロトタイプオブジェクトのメソッドよりも優先して呼ばれている
- この挙動はプロトタイプオブジェクトと呼ばれる特殊なオブジェクトとプロトタイプチェーンと呼ばれる仕組みで成り立っています。

## プロトタイプオブジェクト
- プロトタイプオブジェクトとは、JavaScriptの関数オブジェクトのprototypeプロパティに自動的に作成される特殊なオブジェクトです。 クラスも一種の関数オブジェクトであるため、自動的にprototypeプロパティにプロトタイプオブジェクトが作成されています。
- class構文のメソッド定義は、この（クラスの）プロトタイプオブジェクトのプロパティとして定義されます。
- このように、プロトタイプメソッドはプロトタイプオブジェクトに定義され、インスタンスオブジェクトのメソッドとは異なるオブジェクトに定義されています。そのため、それぞれの方法でメソッドを定義しても、上書きされることはありません。

## プロトタイプチェーン
インスタンスからプロトタイプメソッドを呼び出せるのはプロトタイプチェーンと呼ばれる仕組みによるものです。 プロトタイプチェーンは2つの処理から成り立ちます。

- インスタンス作成時に、インスタンスの[[Prototype]]内部プロパティへ、(生成元クラスの)プロトタイプオブジェクトの参照を保存する処理
- インスタンスからプロパティ（またはメソッド）を参照するときに、[[Prototype]]内部プロパティまで探索する処理

### インスタンス作成とプロトタイプチェーン
- インスタンスを作成する際に、インスタンスにはクラスのプロトタイプオブジェクトへの参照が保存されます。 このとき、インスタンスからクラスのプロトタイプオブジェクトへの参照は、インスタンスオブジェクトの[[Prototype]]という内部プロパティに保存されます。
- ここで重要なのは、インスタンスはどのクラスから作られたかやそのクラスのプロトタイプオブジェクトを知っているということです。

### プロパティの参照とプロトタイプチェーン
- オブジェクトがプロパティを探索するときは次のような順番で、それぞれのオブジェクトを調べます。 すべてのオブジェクトにおいて見つからなかった場合の結果はundefinedを返します。

1. instanceオブジェクト自身
2. instanceオブジェクトの[[Prototype]]の参照先（プロトタイプオブジェクト）
3. どこにもなかった場合はundefined

- プロパティを参照する際に、オブジェクト自身から[[Prototype]]内部プロパティへと順番に探す仕組みのことを**プロトタイプチェーン**と呼びます。

## 継承
extendsキーワードを使うことで既存のクラスを継承できます。 継承とは、クラスの構造や機能を引き継いだ新しいクラスを定義することです。

### 継承したクラスの定義
```
class 子クラス extends 親クラス {

}
```

### super
- extendsを使って定義した子クラスから親クラスを参照するにはsuperというキーワードを利用します。
- 子クラスでconstructorを省略した場合は、constructorメソッドの引数をすべて受け取り、そのままsuperへ引数の順番を維持して渡します。

### コンストラクタの処理順は親クラスから子クラスへ
- そのため、コンストラクタの処理順はParentからChildという順番に限定されます。
  - 子クラスのコンストラクタでは、thisを触る前にsuper()で親クラスのコンストラクタ処理を呼び出さないとReferenceErrorとなる。そのため、class構文では必ず親クラスのコンストラクタ処理（super()の呼び出し）を先に行い、その次に子クラスのコンストラクタ処理を行います。

### プロトタイプ継承
- 子クラスのインスタンスから親クラスのプロトタイプメソッドもプロトタイプチェーンの仕組みによって呼び出せます。

- プロパティを参照する場合には次のような順番でオブジェクトを探索しています。

1. instanceオブジェクト自身
2. Child.prototype（instanceオブジェクトの[[Prototype]]の参照先）
3. Parent.prototype（Child.prototypeオブジェクトの[[Prototype]]の参照先）

- class構文ではプロトタイプオブジェクトを参照する仕組みによって継承が行われています。 そのため、この継承の仕組みをプロトタイプ継承と呼びます。

### 静的メソッドの継承
- 静的メソッドも継承される。

### superプロパティ
- 子クラスのプロトタイプメソッドからは、super.プロパティ名で親クラスのプロトタイプメソッドを参照できます。
- 静的メソッドについても同様

### 継承の判定
- あるクラスが指定したクラスをプロトタイプ継承しているかはinstanceof演算子を使って判定できます。

## ビルトインオブジェクトの継承
- ビルトインオブジェクトのコンストラクタも継承できます。

## まとめ
- JavaScriptのクラスはプロトタイプベース
- クラスはclass構文で定義できる
- クラスで定義したメソッドはプロトタイプオブジェクトとプロトタイプチェーンの仕組みで呼び出せる
- アクセッサプロパティはgetterとsetterのメソッドを定義することでプロパティのように振る舞う
- クラスはextendsで継承できる
- クラスのプロトタイプメソッドと静的メソッドはどちらも継承される

# 例外処理
## try...catch構文
- try...catch構文は例外が発生しうるブロックをマークし、例外が発生したときの処理を記述するための構文です。

```
try {
    console.log("try節:この行は実行されます");
    // 未定義の関数を呼び出してReferenceError例外が発生する
    undefinedFunction();
    // 例外が発生したため、この行は実行されません
} catch (error) {
    // 例外が発生したあとはこのブロックが実行される
    console.log("catch節:この行は実行されます");
    console.log(error instanceof ReferenceError); // => true
    console.log(error.message); // => "undefinedFunction is not defined"
} finally {
    // このブロックは例外の発生に関係なく必ず実行される
    console.log("finally節:この行は実行されます");
}
```

- また、catch節とfinally節のうち、片方が存在していれば、もう片方の節は省略できます。 finally節のみを書いた場合は例外がキャッチされないため、finally節を実行後に例外が発生します。

### throw文
```
try {
    // 例外を投げる
    throw new Error("例外が投げられました");
} catch (error) {
    // catch節のスコープでerrorにアクセスできる
    console.log(error.message); // => "例外が投げられました"
}
```

## エラーオブジェクト
- throw文で例外として投げられるエラーオブジェクトについて見ていきます。

### Error
- throw文はあらゆるオブジェクトを例外として投げられますが、基本的にErrorオブジェクトのインスタンスを投げることを推奨します。 その理由は後述するスタックトレースのためです。

### ビルトインエラー
- エラーには状況に合わせたいくつかの種類があり、これらはビルトインエラーとして定義されています。

#### ReferenceError
- ReferenceErrorは存在しない変数や関数などの識別子が参照された場合のエラーです。

#### SyntaxError
- SyntaxErrorは構文的に不正なコードを解釈しようとした場合のエラーです。

#### TypeError
- TypeErrorは値が期待される型ではない場合のエラーです。

## エラーとデバッグ
- エラーが発生するとログがコンソールに出力される。
- 最初にメッセージが表示される。その次の行以降にスタックとレースが表示され、上から下に呼び出し元を辿れる。

## console.errorとスタックトレース
- console.errorメソッドではメッセージと合わせてスタックトレースをコンソールへ出力できます。

## まとめ
- try...catch構文はtryブロック内で発生した例外を処理できる
- catch節とfinally節は、両方またはどちらか片方を記述する
- throw文は例外を投げることができ、Errorオブジェクトを例外として投げる
- Errorオブジェクトには、ECMAScript仕様や実行環境で定義されたビルトインエラーがある
- Errorオブジェクトには、スタックトレースが記録され、デバッグに役立てられる

# 非同期処理:コールバック/Promise/Async Function

## 同期処理

## 非同期処理はメインスレッドで実行される
- 基本的には非同期処理も同期処理と同じようにメインスレッドで実行されます。
- JavaScriptでは一部の例外を除き非同期処理が並行処理（concurrent）として扱われます。 並行処理とは、処理を一定の単位ごとに分けて処理を切り替えながら実行することです。 そのため非同期処理の実行中にとても重たい処理があると、非同期処理の切り替えが遅れるという現象を引き起こします。
- ただし、非同期処理の中にもメインスレッドとは別のスレッドで実行できるAPIが実行環境によっては存在します。 たとえばブラウザではWeb Worker APIを使い、メインスレッド以外でJavaScriptを実行できます。 このWeb Workerにおける非同期処理は並列処理（Parallel）です。 並列処理とは、排他的に複数の処理を同時に実行することです。
- JavaScriptの大部分の非同期処理は非同期的なタイミングで実行される処理である(別スレッドで並列実行されるわけではない)と理解しておく必要があります。
