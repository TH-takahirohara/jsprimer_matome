# 関数とスコープ

## クロージャー
- クロージャーは、「外側のスコープにある変数への参照を保持できる」という関数が持つ性質のこと。
- 静的スコープ、メモリ管理の仕組みについての理解が必要。

### 静的スコープ
- どの識別子がどの変数を参照しているかを静的に決定する性質を静的スコープと呼ぶ。
- JavaScriptは静的スコープ。

### 動的スコープ
- 呼び出し元のスコープの変数を参照する仕組みを動的スコープという。
- JavaScriptでもthisという特別なキーワードだけは、呼び出し元によって動的に参照先が変わる。

### メモリ管理の仕組み
- 参照されなくなったデータを開放するメモリ管理の仕組みとしてガベージコレクションがある。
- JavaScriptでは、メモリ管理としてガベージコレクションが採用されている。
- よく誤解されるが、関数の中で作成したデータは、その関数の実行が終了した時点で必ずしも解放されるわけではない。
    - 例：　内部で変数aを定義し、その変数aを戻り値とする関数bがあるとする。関数bの呼び出しを別の変数xに代入した場合、aが参照する値はxからも参照され続けるため、データが自動的に開放されることはない。
- そのデータがメモリ上から開放されるかどうかは、そのデータが参照されているかによって決定されるのである。

### クロージャーがなぜ動くのか
クロージャーは、下記2つの仕組みを利用して、関数内から特定の変数を参照し続けることで関数が状態を持てる仕組みのことを言う。
- 静的スコープ: ある変数がどの値を参照するかは静的に決まる
- メモリ管理の仕組み: 参照されなくなったデータはガベージコレクションにより解放される

### クロージャーの用途
クロージャーはさまざまな用途に利用されますが、次のような用途で利用されることが多い。
- 関数に状態を持たせる手段として
- 外から参照できない変数を定義する手段として
- グローバル変数を減らす手段として
- 高階関数の一部部分として

## まとめ
- 関数やブロックはスコープを持つ
- スコープはネストできる
- もっとも外側にはグローバルスコープがある
- スコープチェーンは内側から外側のスコープへと順番に変数が定義されているか探す仕組みのこと
- varキーワードでの変数宣言やfunctionでの関数宣言では巻き上げが発生する
- クロージャーは静的スコープとメモリ管理の仕組みからなる関数が持つ性質

# 関数とthis
https://jsprimer.net/basic/function-this/

- thisキーワードは基本的にはメソッドの中で利用するが、読み取り専用のグローバル変数のようなものでどこにでもかける。
- thisの参照先は主に次の条件によって変化する。
  - 実行コンテキストにおけるthis
  - コンストラクタにおけるthis
  - 関数とメソッドにおけるthis
  - Arrow Functionにおけるthis

## 実行コンテキストとthis

### スクリプトにおけるthis
- 実行コンテキストが"Script"である場合、トップレベルのスコープに書かれたthisはグローバルオブジェクトを参照します。
  - ブラウザのグローバルオブジェクトはwindowオブジェクト

 ### モジュールにおけるthis
- 実行コンテキストが"Module"である場合、そのトップレベルのスコープに書かれたthisは常にundefinedとなります。

## 関数とメソッドにおけるthis
- thisが参照先を決めるルールは、Arrow Functionとそれ以外の関数定義の方法で異なります。

### 関数の種類
```
// `function`キーワードからはじめる関数宣言
function fn1() {}
// `function`を式として扱う関数式
const fn2 = function() {};
// Arrow Functionを使った関数式
const fn3 = () => {};
```

### メソッドの種類
- JavaScriptではオブジェクトのプロパティが関数である場合にそれをメソッドと呼びます。

|  名前  |  関数  |  メソッド  |
| ---- | ---- | ---- |
|  関数宣言(function fn(){})  |  ○  |  ×  |
|  関数式(const fn = function(){})  |  ○  |  ○  |
|  Arrow Function(const fn = () => {})  |  ○  |  ○  |
|  メソッドの短縮記法(const obj = { method(){} })  |  ×  |  ○  |

## Arrow Function以外の関数におけるthis
- Arrow Function以外の関数（メソッドも含む）におけるthisは、実行時に決まる値となります。 言い方を変えるとthisは関数に渡される暗黙的な引数のようなもので、その渡される値は関数を実行するときに決まります。
- 関数におけるthisの基本的な参照先（暗黙的に関数に渡すthisの値）はベースオブジェクトとなります。 ベースオブジェクトとは「メソッドを呼ぶ際に、そのメソッドのドット演算子またはブラケット演算子のひとつ左にあるオブジェクト」のことを言います。
  - ベースオブジェクトがない場合のthisはundefinedとなります。
- thisは関数の定義ではなく呼び出し方で参照する値が異なるので注意

### 関数宣言や関数式におけるthis
- メソッド以外でthisを使う必要はない。

### メソッド呼び出しにおけるthis
- メソッドの場合は、そのメソッドが何かしらのオブジェクトに所属しています。ベースオブジェクトとして、その所属するオブジェクトが取得できます。

## thisが問題となるパターン
- thisには、どの値を参照するかは関数の呼び出し時に決まるという性質に由来したいろいろな問題がある。

### 問題：thisを含むメソッドを変数に代入した場合
- メソッドとして定義した関数も、別の変数に代入すると実行時にはただの関数であるためベースオブジェクトが変わってしまっている。
- 対処法は大きく分けて2つある。
  - メソッドとして定義されている関数はメソッドとして呼ぶと言うこと
  - thisの値を指定して関数を呼べるメソッドで関数を実行する方法（下記対処法参照）
- 基本的には前者のやり方で問題を回避し、どうしてもthisを固定したい場合には後者の方法を取るのが良い。

#### 対処法: call、apply、bindメソッド
- callメソッド
`関数.call(thisの値, ...関数の引数);`

- applyメソッド
`関数.apply(thisの値, [関数の引数1, 関数の引数2]);`

- bindメソッド
`関数.bind(thisの値, ...関数の引数); // => thisや引数がbindされた関数`

### 問題：コールバック関数とthis
- コールバック関数の中でthisを参照すると問題となる場合があります。
- この問題は、メソッドの中でArray#mapメソッドなどのコールバック関数を扱う場合に発生しやすいです。
- Array#mapメソッドに渡しているコールバック関数はcallback()のようにただの関数として呼び出されるため、callback関数のthisはundefinedとなる。

#### 対処法: thisを一時変数へ代入する

#### 対処法: Arrow Functionでコールバック関数を扱う
- Arrow Functionは呼び出し時に暗黙的なthisの値を受け取りません。そのためArrow Function内のthisは、スコープチェーンの仕組みと同様に外側の関数を探索します。これにより、Arrow Functionで定義したコールバック関数は呼び出し方には関係なく、常に外側の関数のthisをそのまま利用します。

## Arrow Functionとthis
- Arrow Functionとそれ以外の関数で大きく違うことは、Arrow Functionはthisを暗黙的な引数として受けつけないということです。
- そのため、Arrow Function内にはthisが定義されていません。このときのthisは外側のスコープ（関数）のthisを参照します。これは、変数におけるスコープチェーンの仕組みと同様で、そのスコープにthisが定義されていない場合には外側のスコープを探索します。
- Arrow Functionにおけるthisは、「Arrow Function自身の外側のスコープに定義されたもっとも近い関数のthisの値」となる。

### メソッドとコールバック関数とArrow Function
- Arrow Functionにおけるthisは呼び出し方の影響を受けません。 つまり、コールバック関数がどのように呼ばれるかという実装についてを考えることなくthisを扱えます。

### Arrow Functionはthisをbindできない
- Arrow Functionで定義した関数ではcall、apply、bindを使ったthisの指定は単に無視されます。 これは、Arrow Functionはthisを持てないためです。

## まとめ
-  メソッド以外においてもthisは評価できますが、実行コンテキストやstrict modeなどによって結果が異なり、混乱の元となります。 そのため、メソッドではない通常の関数においてはthisを使うべきではありません。
- コールバック関数におけるthisはArrow Functionを使うことでわかりやすく解決できます。

# クラス
- クラスとは動作や状態を定義した構造である。 クラスからはインスタンスと呼ばれるオブジェクトを作成できる。インスタンスはクラスに定義した動作を継承し、状態は動作によって変化する。

## クラスの定義
- クラスを定義するにはclass構文を使います。 クラスの定義方法にはクラス宣言文とクラス式があります。

- クラス宣言文によるクラスの定義方法
```
class MyClass {
    constructor() {
        // コンストラクタ関数の処理
        // インスタンス化されるときに自動的に呼び出される
    }
}
```

- クラス式による定義方法。クラスを値として定義する。クラス式ではクラス名を省略できる。
```
const MyClass = class MyClass {
    constructor() {}
};

const AnonymousClass = class {
    constructor() {}
};
```

## クラスのインスタンス化
- クラスはnew演算子でインスタンスであるオブジェクトを作成できます。
```
class MyClass {
}
// `MyClass`をインスタンス化する
const myClass = new MyClass();
// 毎回新しいインスタンス(オブジェクト)を作成する
const myClassAnother = new MyClass();
// それぞれのインスタンスは異なるオブジェクト
console.log(myClass === myClassAnother); // => false
// クラスのインスタンスかどうかは`instanceof`演算子で判定できる
console.log(myClass instanceof MyClass); // => true
console.log(myClassAnother instanceof MyClass); // => true
```

- クラスではインスタンスの初期化処理をコンストラクタ関数で行います。 コンストラクタ関数はnew演算子でインスタンス化する際に自動的に呼び出されます。 コンストラクタ関数内でのthisはこれから新しく作るインスタンスオブジェクトとなります。

```
class Point {
    // 2. コンストラクタ関数の仮引数として`x`には`3`、`y`には`4`が渡る
    constructor(x, y) {
        // 3. インスタンス(`this`)の`x`と`y`プロパティにそれぞれ値を設定する
        this.x = x;
        this.y = y;
        // コンストラクタではreturn文は書かない
    }
}

// 1. コンストラクタを`new`演算子で引数とともに呼び出す
const point = new Point(3, 4);
// 4. `Point`のインスタンスである`point`の`x`と`y`プロパティには初期化された値が入る
console.log(point.x); // => 3
console.log(point.y); // => 4
```

- コンストラクタは初期化処理を書く場所であるため、return文で値を返すべきではありません。
- クラス名は大文字ではじめる

## [コラム] class構文と関数でのクラスの違い
- 関数でクラスのようなものを実装した場合には、関数として呼び出せてしまう問題があります。 

## クラスのプロトタイプメソッドの定義
- class構文ではクラスに対してメソッドを定義できます。メソッドの中からクラスのインスタンスを参照するには、constructorメソッドと同じくthisを使います。
```
class クラス {
    メソッド() {
        // ここでの`this`はベースオブジェクトを参照
    }
}

const インスタンス = new クラス();
// メソッド呼び出しのベースオブジェクト(`this`)は`インスタンス`となる
インスタンス.メソッド();
```

- このようにクラスに対して定義したメソッドは、クラスの各インスタンスから共有されるメソッドとなります。 このインスタンス間で共有されるメソッドのことをプロトタイプメソッドと呼びます。 また、プロトタイプメソッドはインスタンスから呼び出せるメソッドであるためインスタンスメソッドとも呼ばれます。
- プロトタイプメソッドは各インスタンス間で共有されるので、参照先は同じになる。

## クラスのインスタンスに対してメソッドを定義する
- クラスのインスタンスに対して、直接メソッドを定義する方法もあります。これは、コンストラクタ関数内でインスタンスオブジェクトであるthisに対してメソッドを定義するだけです。
- この場合、プロトタイプメソッドとは異なり、インスタンス作成時に毎回関数を新しく定義しているので、各インスタンスからのメソッドの参照先は異なる。（プロトタイプメソッドではメソッドの参照先は同じだった。）
- また、プロトタイプメソッドとは異なり、インスタンスオブジェクトへのメソッド定義はArrow Functionが利用できます。この場合、メソッド内のthisの参照先を固定化できる。

## クラスのアクセッサプロパティの定義
```
class クラス {
    // getter
    get プロパティ名() {
        return 値;
    }
    // setter
    set プロパティ名(仮引数) {
        // setterの処理
    }
}
const インスタンス = new クラス();
インスタンス.プロパティ名; // getterが呼び出される
インスタンス.プロパティ名 = 値; // setterが呼び出される
```

- アクセッサプロパティで実際に読み書きしているプロパティを`_value`などと`_`で開始する習慣がある。構文としての意味はない。

## 静的メソッド
- クラスをインスタンス化せずに利用できる静的メソッド（クラスメソッド）もあります。
- 静的メソッドの定義方法はメソッド名の前に、staticをつけるだけです。

```
class クラス {
    static メソッド() {
        // 静的メソッドの処理
    }
}
// 静的メソッドの呼び出し
クラス.メソッド();
```

- クラスの静的メソッドにおけるthisは、そのクラス自身を参照します。
- 静的メソッドは、クラスのインスタンスを作成する処理やクラスに関係する処理を書くために利用されます。

## 2種類のインスタンスメソッドの定義
- プロトタイプメソッドの定義と、 インスタンスオブジェクトに対するメソッドの定義を同時に使い、1つのクラスに同じ名前でメソッドを2つ定義した場合、下記のようになる。
  - プロトタイプメソッドとインスタンスオブジェクトのメソッドは上書きされずにどちらも定義されている
  - インスタンスオブジェクトのメソッドがプロトタイプオブジェクトのメソッドよりも優先して呼ばれている
- この挙動はプロトタイプオブジェクトと呼ばれる特殊なオブジェクトとプロトタイプチェーンと呼ばれる仕組みで成り立っています。

## プロトタイプオブジェクト
- プロトタイプオブジェクトとは、JavaScriptの関数オブジェクトのprototypeプロパティに自動的に作成される特殊なオブジェクトです。 クラスも一種の関数オブジェクトであるため、自動的にprototypeプロパティにプロトタイプオブジェクトが作成されています。
- class構文のメソッド定義は、この（クラスの）プロトタイプオブジェクトのプロパティとして定義されます。
- このように、プロトタイプメソッドはプロトタイプオブジェクトに定義され、インスタンスオブジェクトのメソッドとは異なるオブジェクトに定義されています。そのため、それぞれの方法でメソッドを定義しても、上書きされることはありません。

## プロトタイプチェーン
インスタンスからプロトタイプメソッドを呼び出せるのはプロトタイプチェーンと呼ばれる仕組みによるものです。 プロトタイプチェーンは2つの処理から成り立ちます。

- インスタンス作成時に、インスタンスの[[Prototype]]内部プロパティへ、(生成元クラスの)プロトタイプオブジェクトの参照を保存する処理
- インスタンスからプロパティ（またはメソッド）を参照するときに、[[Prototype]]内部プロパティまで探索する処理

### インスタンス作成とプロトタイプチェーン
- インスタンスを作成する際に、インスタンスにはクラスのプロトタイプオブジェクトへの参照が保存されます。 このとき、インスタンスからクラスのプロトタイプオブジェクトへの参照は、インスタンスオブジェクトの[[Prototype]]という内部プロパティに保存されます。
- ここで重要なのは、インスタンスはどのクラスから作られたかやそのクラスのプロトタイプオブジェクトを知っているということです。

### プロパティの参照とプロトタイプチェーン
- オブジェクトがプロパティを探索するときは次のような順番で、それぞれのオブジェクトを調べます。 すべてのオブジェクトにおいて見つからなかった場合の結果はundefinedを返します。

1. instanceオブジェクト自身
2. instanceオブジェクトの[[Prototype]]の参照先（プロトタイプオブジェクト）
3. どこにもなかった場合はundefined

- プロパティを参照する際に、オブジェクト自身から[[Prototype]]内部プロパティへと順番に探す仕組みのことを**プロトタイプチェーン**と呼びます。

## 継承
extendsキーワードを使うことで既存のクラスを継承できます。 継承とは、クラスの構造や機能を引き継いだ新しいクラスを定義することです。

### 継承したクラスの定義
```
class 子クラス extends 親クラス {

}
```

### super
- extendsを使って定義した子クラスから親クラスを参照するにはsuperというキーワードを利用します。
- 子クラスでconstructorを省略した場合は、constructorメソッドの引数をすべて受け取り、そのままsuperへ引数の順番を維持して渡します。

### コンストラクタの処理順は親クラスから子クラスへ
- そのため、コンストラクタの処理順はParentからChildという順番に限定されます。
  - 子クラスのコンストラクタでは、thisを触る前にsuper()で親クラスのコンストラクタ処理を呼び出さないとReferenceErrorとなる。そのため、class構文では必ず親クラスのコンストラクタ処理（super()の呼び出し）を先に行い、その次に子クラスのコンストラクタ処理を行います。

### プロトタイプ継承
- 子クラスのインスタンスから親クラスのプロトタイプメソッドもプロトタイプチェーンの仕組みによって呼び出せます。

- プロパティを参照する場合には次のような順番でオブジェクトを探索しています。

1. instanceオブジェクト自身
2. Child.prototype（instanceオブジェクトの[[Prototype]]の参照先）
3. Parent.prototype（Child.prototypeオブジェクトの[[Prototype]]の参照先）

- class構文ではプロトタイプオブジェクトを参照する仕組みによって継承が行われています。 そのため、この継承の仕組みをプロトタイプ継承と呼びます。

### 静的メソッドの継承
- 静的メソッドも継承される。

### superプロパティ
- 子クラスのプロトタイプメソッドからは、super.プロパティ名で親クラスのプロトタイプメソッドを参照できます。
- 静的メソッドについても同様

### 継承の判定
- あるクラスが指定したクラスをプロトタイプ継承しているかはinstanceof演算子を使って判定できます。

## ビルトインオブジェクトの継承
- ビルトインオブジェクトのコンストラクタも継承できます。

## まとめ
- JavaScriptのクラスはプロトタイプベース
- クラスはclass構文で定義できる
- クラスで定義したメソッドはプロトタイプオブジェクトとプロトタイプチェーンの仕組みで呼び出せる
- アクセッサプロパティはgetterとsetterのメソッドを定義することでプロパティのように振る舞う
- クラスはextendsで継承できる
- クラスのプロトタイプメソッドと静的メソッドはどちらも継承される

# 例外処理
## try...catch構文
- try...catch構文は例外が発生しうるブロックをマークし、例外が発生したときの処理を記述するための構文です。

```
try {
    console.log("try節:この行は実行されます");
    // 未定義の関数を呼び出してReferenceError例外が発生する
    undefinedFunction();
    // 例外が発生したため、この行は実行されません
} catch (error) {
    // 例外が発生したあとはこのブロックが実行される
    console.log("catch節:この行は実行されます");
    console.log(error instanceof ReferenceError); // => true
    console.log(error.message); // => "undefinedFunction is not defined"
} finally {
    // このブロックは例外の発生に関係なく必ず実行される
    console.log("finally節:この行は実行されます");
}
```

- また、catch節とfinally節のうち、片方が存在していれば、もう片方の節は省略できます。 finally節のみを書いた場合は例外がキャッチされないため、finally節を実行後に例外が発生します。

### throw文
```
try {
    // 例外を投げる
    throw new Error("例外が投げられました");
} catch (error) {
    // catch節のスコープでerrorにアクセスできる
    console.log(error.message); // => "例外が投げられました"
}
```

## エラーオブジェクト
- throw文で例外として投げられるエラーオブジェクトについて見ていきます。

### Error
- throw文はあらゆるオブジェクトを例外として投げられますが、基本的にErrorオブジェクトのインスタンスを投げることを推奨します。 その理由は後述するスタックトレースのためです。

### ビルトインエラー
- エラーには状況に合わせたいくつかの種類があり、これらはビルトインエラーとして定義されています。

#### ReferenceError
- ReferenceErrorは存在しない変数や関数などの識別子が参照された場合のエラーです。

#### SyntaxError
- SyntaxErrorは構文的に不正なコードを解釈しようとした場合のエラーです。

#### TypeError
- TypeErrorは値が期待される型ではない場合のエラーです。

## エラーとデバッグ
- エラーが発生するとログがコンソールに出力される。
- 最初にメッセージが表示される。その次の行以降にスタックとレースが表示され、上から下に呼び出し元を辿れる。

## console.errorとスタックトレース
- console.errorメソッドではメッセージと合わせてスタックトレースをコンソールへ出力できます。

## まとめ
- try...catch構文はtryブロック内で発生した例外を処理できる
- catch節とfinally節は、両方またはどちらか片方を記述する
- throw文は例外を投げることができ、Errorオブジェクトを例外として投げる
- Errorオブジェクトには、ECMAScript仕様や実行環境で定義されたビルトインエラーがある
- Errorオブジェクトには、スタックトレースが記録され、デバッグに役立てられる

# 非同期処理:コールバック/Promise/Async Function
https://jsprimer.net/basic/async/

## 同期処理

## 非同期処理はメインスレッドで実行される
- 基本的には非同期処理も同期処理と同じようにメインスレッドで実行されます。
- JavaScriptでは一部の例外を除き非同期処理が並行処理（concurrent）として扱われます。 並行処理とは、処理を一定の単位ごとに分けて処理を切り替えながら実行することです。 そのため非同期処理の実行中にとても重たい処理があると、非同期処理の切り替えが遅れるという現象を引き起こします。
- ただし、非同期処理の中にもメインスレッドとは別のスレッドで実行できるAPIが実行環境によっては存在します。 たとえばブラウザではWeb Worker APIを使い、メインスレッド以外でJavaScriptを実行できます。 このWeb Workerにおける非同期処理は並列処理（Parallel）です。 並列処理とは、排他的に複数の処理を同時に実行することです。
- JavaScriptの大部分の非同期処理は非同期的なタイミングで実行される処理である(別スレッドで並列実行されるわけではない)と理解しておく必要があります。

## 非同期処理と例外処理
- 非同期処理では、try...catch構文を使っても非同期的に発生した例外をキャッチできません。
- コールバック関数内でエラーをキャッチできますが、非同期処理の外からは非同期処理の中で例外が発生したかがわかりません。

- 主要な非同期処理と例外の扱い方としてエラーファーストコールバック、Promise、Async Functionの3つを見ていきます。 

## エラーファーストコールバック
- エラーファーストコールバックとは、次のような非同期処理におけるコールバック関数の呼び出し方を決めたルールです。

  - 処理が失敗した場合は、コールバック関数の1番目の引数にエラーオブジェクトを渡して呼び出す
  - 処理が成功した場合は、コールバック関数の1番目の引数にはnullを渡し、2番目以降の引数に成功時の結果を渡して呼び出す

例
```
fs.readFile("./example.txt", (error, data) => {
    if (error) {
        // 読み込み中にエラーが発生しました
    } else {
        // データを読み込むことができました
    }
});
```

- エラーファーストコールバックは非同期処理におけるエラーハンドリングの書き方を決めたただのルールであって仕様ではありません。

## [ES2015] Promise
- 次のコードのasyncPromiseTask関数はPromiseインスタンスを返す非同期処理の例です。 Promiseでは、非同期処理に成功したときの処理をコールバック関数としてthenメソッドへ渡し、 失敗したときの処理を同じくコールバック関数としてcatchメソッドへ渡します。
- エラーファーストコールバックとは異なり、非同期処理（asyncPromiseTask関数）はPromiseインスタンスを返しています。 その返されたPromiseインスタンスに対して、成功と失敗時の処理をそれぞれコールバック関数として渡すという形になります。

```
// asyncPromiseTask関数はPromiseインスタンスを返す
asyncPromiseTask().then(()=> {
    // 非同期処理が成功したときの処理
}).catch(() => {
    // 非同期処理が失敗したときの処理
});
```

- 複雑な非同期処理をうまくパターン化できるというのがPromiseの役割であり、 Promiseを使う理由のひとつであると言えるでしょう。

### Promiseインスタンスの作成
```
// `Promise`インスタンスを作成
const promise = new Promise((resolve, reject) => {
    // 非同期の処理が成功したときはresolve()を呼ぶ
    // 非同期の処理が失敗したときにはreject()を呼ぶ
});
const onFulfilled = () => {
    console.log("resolveされたときに呼ばれる");
};
const onRejected = () => {
    console.log("rejectされたときに呼ばれる");
};
// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録
promise.then(onFulfilled, onRejected);
```

### Promise#thenとPromise#catch
```
/**
 * 1000ミリ秒未満のランダムなタイミングでレスポンスを疑似的にデータ取得する関数
 * 指定した`path`にデータがある場合、成功として**Resolved**状態のPromiseオブジェクトを返す
 * 指定した`path`にデータがない場合、失敗として**Rejected**状態のPromiseオブジェクトを返す
 */
function dummyFetch(path) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (path.startsWith("/success")) {
                resolve({ body: `Response body of ${path}` });
            } else {
                reject(new Error("NOT FOUND"));
            }
        }, 1000 * Math.random());
    });
}
// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録
// /success/data のリソースは存在するので成功しonFulfilledが呼ばれる
dummyFetch("/success/data").then(function onFulfilled(response) {
    console.log(response); // => { body: "Response body of /success/data" }
}, function onRejected(error) {
    // この行は実行されません
});
// /failure/data のリソースは存在しないのでonRejectedが呼ばれる
dummyFetch("/failure/data").then(function onFulfilled(response) {
    // この行は実行されません
}, function onRejected(error) {
    console.log(error); // Error: "NOT FOUND"
});

```

Promise#catchを使う例
```
function errorPromise(message) {
    return new Promise((resolve, reject) => {
        reject(new Error(message));
    });
}
// 非推奨: `then`メソッドで失敗時のコールバック関数だけを登録
errorPromise("thenでエラーハンドリング").then(undefined, (error) => {
    console.log(error.message); // => "thenでエラーハンドリング"
});
// 推奨: `catch`メソッドで失敗時のコールバック関数を登録
errorPromise("catchでエラーハンドリング").catch(error => {
    console.log(error.message); // => "catchでエラーハンドリング"
});
```

### Promiseと例外
- Promiseではコンストラクタの処理で例外が発生した場合に自動的に（try...catch構文を使わずに）例外がキャッチされます。 例外が発生したPromiseインスタンスはreject関数を呼び出したのと同じように失敗したものとして扱われます。 

### Promiseの状態
- Promiseインスタンスの状態は作成時にPendingとなり、一度でもFulfilledまたはRejectedへ変化すると、それ以降状態は変化しなくなります。 そのため、FulfilledまたはRejectedの状態であることをSettled（不変）と呼びます。
- 一度でもSettled（FulfilledまたはRejected）となったPromiseインスタンスは、それ以降別の状態には変化しません。

### Promise.resolve

### Promise.reject

### Promiseチェーン
- 非同期処理が終わったら次の非同期処理というように、複数の非同期処理を順番に扱いたい場合もあります。 Promiseではこのような複数の非同期処理からなる一連の非同期処理を簡単に書く方法が用意されています。
- この仕組みのキーとなるのがthenやcatchメソッドは常に新しいPromiseインスタンスを作成して返すという仕様です。 そのためthenメソッドの返り値であるPromiseインスタンスにさらにthenメソッドで処理を登録できます。これはメソッドチェーンと呼ばれる仕組みですが、この書籍ではPromiseをメソッドチェーンでつなぐことをPromiseチェーンと呼びます。

- Promiseチェーンで失敗をcatchメソッドなどで一度キャッチすると、次に呼ばれるのは成功時の処理です。 これは、thenやcatchメソッドはFulfilled状態のPromiseインスタンスを作成して返すためです。 そのため、一度キャッチするとそこからは元のthenで登録した処理が呼ばれるPromiseチェーンに戻ります。
```
Promise.reject(new Error("エラー")).catch(error => {
    console.log(error); // Error: エラー
}).then(() => {
    console.log("thenのコールバック関数が呼び出される");
});
```

### Promiseチェーンで値を返す

### コールバック関数でPromiseインスタンスを返す
- コールバック関数でPromiseインスタンスを返した場合は、同じ状態を持つPromiseインスタンスがthenやcatchメソッドの返り値となります。

### [ES2018] Promiseチェーンの最後に処理を書く
- Promise#finallyメソッドは成功時、失敗時どちらの場合でも呼び出されるコールバック関数を登録できます。

### Promiseチェーンで逐次処理
- Promiseチェーンで非同期処理の流れを書く大きなメリットは、非同期処理のさまざまなパターンに対応できることです。

### Promise.allで複数のPromiseをまとめる
- Promise.allを使うことで複数のPromiseを使った非同期処理をひとつのPromiseとして扱えます。
```
Promise.all([promise1, promise2, promise3]).then(function(values) {
    console.log(values);
});
```

### Promise.race
- Promise.raceメソッドでは複数のPromiseを受け取りますが、Promiseが1つでも完了した（Settle状態となった）時点で、その完了したPromiseインスタンスに対する次の処理を実行します。
- Promise.raceメソッドを使うことでPromiseを使った非同期処理のタイムアウトが実装できます。ここでのタイムアウトとは、一定時間経過しても処理が終わっていないならエラーとして扱う処理のことです。

- より詳しいPromiseの使い方は「[JavaScript Promiseの本](https://azu.github.io/promises-book/)」を参照

## [ES2017] Async Function
- Async Functionは通常の関数とは異なり、必ずPromiseインスタンスを返す関数を定義する構文です。
```
async function doAsync() {
    return "値";
}
// doAsync関数はPromiseを返す
doAsync().then(value => {
    console.log(value); // => "値"
});
```

- このAsync Functionは次のように書いた場合と同じ意味になります。
```
// 通常の関数でPromiseインスタンスを返している
function doAsync() {
    return Promise.resolve("値");
}
doAsync().then(value => {
    console.log(value); // => "値"
});
```

## Async Functionの定義
- Async Functionは、次の点以外は通常の関数と同じ性質を持ちます。

  - Async Functionは必ずPromiseインスタンスを返す
  - Async Function内ではawait式が利用できる

## Async FunctionはPromiseを返す
- 具体的にはAsync Functionが返す値は次の3つのケースが考えられます。

1. Async Functionが値をreturnした場合、その返り値を持つFulfilledなPromiseを返す
2. Async FunctionがPromiseをreturnした場合、その返り値のPromiseをそのまま返す
3. Async Function内で例外が発生した場合は、そのエラーを持つRejectedなPromiseを返す

## await式
- Async Functionの関数内ではawait式を利用できます。
- await式は右辺のPromiseインスタンスがFulfilledまたはRejectedになるまでその場で非同期処理の完了を待ちます。
- そしてPromiseインスタンスの状態が変わると、次の行の処理を再開します。

```
async function asyncMain() {
    // PromiseがFulfilledまたはRejectedとなるまで待つ
    await Promiseインスタンス;
    // Promiseインスタンスの状態が変わったら処理を再開する
}
```

- await式を使うことで、try...catch構文のように非同期処理を同期処理と同じ構文を使って扱えます。

## Promiseチェーンをawait式で表現する

## Async Functionと組み合わせ

### Async Functionと反復処理
- Async Functionでは、非同期処理であってもforループのような既存の構文と組み合わせて利用することが簡単です。

## Promise APIとAsync Functionを組み合わせる
- await式が評価するのはPromiseインスタンスであるため、await式も例えばPromise.allメソッドと組み合わせて利用できます。

## await式はAsync Functionの中でのみ利用可能
- Async Functionとコールバック関数を組み合わせた場合には予期せぬ挙動をすることがあるので気をつける必要があります。

## まとめ
- 非同期処理はその処理が終わるのを待つ前に次の処理を評価すること
- 非同期処理であってもメインスレッドで実行されることがある
- エラーファーストコールバックは、非同期処理での例外を扱うルールの1つ
- Promiseは、ES2015で導入された非同期処理を扱うビルトインオブジェクト
- Async Functionは、ES2017で導入された非同期処理を扱う構文
- Async FunctionはPromiseの上に作られた構文であるため、Promiseと組み合わせて利用する

PromiseやAsync Functionの応用パターンについては「[JavaScript Promiseの本](http://azu.github.io/promises-book/)」も参照してください。

# Map/Set
 https://jsprimer.net/basic/map-and-set/

## Map

### マップの作成と初期化

 ```
const map = new Map();
console.log(map.size); // => 0

const map = new Map([["key1", "value1"], ["key2", "value2"]]);
// 2つのエントリーで初期化されている。エントリーとは、1つのキーと値の組み合わせを[キー, 値]という形式の配列で表現したもの。
console.log(map.size); // => 2
 ```

### 要素の追加と取り出し

### マップの反復処理
- マップが持つ要素を列挙するメソッドとして、forEach、keys、values、entriesがあります。

### マップとしてのObjectとMap
- 何かをキーにして値にアクセスするという点で、MapとObjectはよく似ています。 ただし、マップとしてのObjectにはいくつかの問題があります。

  - Objectのprototypeオブジェクトから継承されたプロパティによって、意図しないマッピングを生じる危険性がある
  - また、プロパティとしてデータを持つため、キーとして使えるのは文字列かSymbolに限られる

- Objectをマップとして使うときに起きる多くの問題は、Mapオブジェクトを使うことで解決するが、マップとしてのObjectには次のような利点があります。

  - リテラル表現があるため作成しやすい
  - 規定のJSON表現があるため、JSON.stringify関数を使ってJSONに変換するのが簡単である
  - ネイティブAPI・外部ライブラリを問わず、多くの関数がマップとしてObjectを渡される設計になっている

### WeakMap
- WeakMapは、Mapと同じくマップを扱うためのビルトインオブジェクトです。 Mapと違う点は、キーを弱い参照（Weak Reference）で持つことです。

## Set
- Setはセット型のコレクションを扱うためのビルトインオブジェクトです。 セットとは、重複する値がないことを保証したコレクションのことを言います。 Setは追加した値を列挙できるので、値が重複しないことを保証する配列のようなものとしてよく使われます。 ただし、配列と違って要素は順序を持たず、インデックスによるアクセスはできません。

### セットの作成と初期化
```
const set = new Set();
console.log(set.size); // => 0

// "value2"が重複するため、片方は無視される
const set = new Set(["value1", "value2", "value2"]);
// セットのサイズは2になる
console.log(set.size); // => 2
```

### 値の追加と取り出し

### セットの反復処理

### WeakSet

## まとめ
- Mapはキーと値の組み合わせからなるコレクションを扱うビルトインオブジェクト
- Mapのキーはプロトタイプオブジェクトのプロパティと名前が衝突しないため意図しないマッピングを避けられる
- WeakMapはキーを弱い参照で持つMapと同様のビルトインオブジェクト
- Setは重複する値がないことを保証した順序を持たないコレクションを扱うビルトインオブジェクト
- WeakSetは値を弱い参照で持つSetと同様のビルトインオブジェクト

# JSON
https://jsprimer.net/basic/json/

- JSONの細かい仕様は[json.orgの日本語ドキュメント](https://www.json.org/json-ja.html)にわかりやすくまとまっているので、参考にするとよいでしょう。

## JSONオブジェクト
### JSON文字列をオブジェクトに変換する
```
// JSONはダブルクォートのみを許容するため、シングルクォートでJSON文字列を記述
const json = '{ "id": 1, "name": "js-primer" }';
const obj = JSON.parse(json);
console.log(obj.id); // => 1
console.log(obj.name); // => "js-primer"
```

- 与えられた文字列がJSON形式でパースできない場合は例外が投げられます。 

### オブジェクトをJSON文字列に変換する
```
const obj = { id: 1, name: "js-primer", bio: null };
console.log(JSON.stringify(obj)); // => '{"id":1,"name":"js-primer","bio":null}'
```

- JSON.stringifyメソッドにはオプショナルな引数が2つあります。
  - 第二引数：replacer
    - 引数として関数か配列を渡すことができ、文字列に変換される際の挙動をコントロールできる。
  - 第三引数：space
    - 変換後のJSON形式の文字列を読みやすくフォーマットする際のインデントを設定できる。

## JSONにシリアライズできないオブジェクト
- いろいろあって、nullに変換されるなどオブジェクトごとに異なる挙動となる。

## toJSONメソッドを使ったシリアライズ
- オブジェクトがtoJSONメソッドを持っている場合、JSON.stringifyメソッドは既定の文字列変換ではなくtoJSONメソッドの返り値を使います。
- toJSONメソッドは自作のクラスを特殊な形式でシリアライズする目的などに使われます。

## まとめ
- JSONはJavaScriptのオブジェクトリテラルをベースに作られた軽量なデータフォーマット
- JSONオブジェクトを使ったシリアライズとデシリアライズ
- JSON形式にシリアライズできないオブジェクトもある
- JSON.stringifyはシリアライズ対象のtoJSONメソッドを利用する

# Date

## Dateオブジェクト
- Dateオブジェクトをインスタンス化することで、ある特定の時刻を表すオブジェクトが得られます。 Dateにおける「時刻」は、UTC（協定世界時）の1970年1月1日0時0分0秒を基準とした相対的なミリ秒として保持されます。

### インスタンスの作成
- Dateオブジェクトのインスタンスは、常にnew演算子を使って作成します。 
- Dateオブジェクトのインスタンス作成には、大きく分けて2つの種類があります。 1つは現在の時刻をインスタンス化するもの、もう1つは任意の時刻をインスタンス化するものです。

#### 現在の時刻をインスタンス化する
```
// 現在の時刻を表すインスタンスを作成する
const now = new Date();
// 時刻値だけが欲しい場合にはDate.nowメソッドを使う
console.log(Date.now());
```

#### 任意の時刻をインスタンス化する
- Dateのコンストラクタ関数は渡すデータ型や引数によって時刻の指定方法が変わります。 Dateは次の3種類を引数としてサポートしています。
- 時刻値を渡すもの
```
// 時刻のミリ秒値を直接指定する形式
// 1136214245999はUTCにおける"2006年1月2日15時04分05秒999"を表す
const date = new Date(1136214245999);
```
- 時刻を示す文字列を渡すもの
```
// UTCにおける"2006年1月2日15時04分05秒999"を表すISO 8601形式の文字列
const inUTC = new Date("2006-01-02T15:04:05.999Z");
```
- 時刻の部分（年・月・日など）をそれぞれ数値で渡すもの
```
const date1 = new Date(2006, 0, 2, 15, 4, 5, 999);
// Date.UTCメソッドを使うとUTCに固定できる
const ms = Date.UTC(2006, 0, 2, 15, 4, 5, 999);
// 時刻値を渡すコンストラクタと併用する
const date2 = new Date(ms);
```
