# 関数とスコープ

## クロージャー
- クロージャーは、「外側のスコープにある変数への参照を保持できる」という関数が持つ性質のこと。
- 静的スコープ、メモリ管理の仕組みについての理解が必要。

### 静的スコープ
- どの識別子がどの変数を参照しているかを静的に決定する性質を静的スコープと呼ぶ。
- JavaScriptは静的スコープ。

### 動的スコープ
- 呼び出し元のスコープの変数を参照する仕組みを動的スコープという。
- JavaScriptでもthisという特別なキーワードだけは、呼び出し元によって動的に参照先が変わる。

### メモリ管理の仕組み
- 参照されなくなったデータを開放するメモリ管理の仕組みとしてガベージコレクションがある。
- JavaScriptでは、メモリ管理としてガベージコレクションが採用されている。
- よく誤解されるが、関数の中で作成したデータは、その関数の実行が終了した時点で必ずしも解放されるわけではない。
    - 例：　内部で変数aを定義し、その変数aを戻り値とする関数bがあるとする。関数bの呼び出しを別の変数xに代入した場合、aが参照する値はxからも参照され続けるため、データが自動的に開放されることはない。
- そのデータがメモリ上から開放されるかどうかは、そのデータが参照されているかによって決定されるのである。

### クロージャーがなぜ動くのか
クロージャーは、下記2つの仕組みを利用して、関数内から特定の変数を参照し続けることで関数が状態を持てる仕組みのことを言う。
- 静的スコープ: ある変数がどの値を参照するかは静的に決まる
- メモリ管理の仕組み: 参照されなくなったデータはガベージコレクションにより解放される

### クロージャーの用途
クロージャーはさまざまな用途に利用されますが、次のような用途で利用されることが多い。
- 関数に状態を持たせる手段として
- 外から参照できない変数を定義する手段として
- グローバル変数を減らす手段として
- 高階関数の一部部分として

## まとめ
- 関数やブロックはスコープを持つ
- スコープはネストできる
- もっとも外側にはグローバルスコープがある
- スコープチェーンは内側から外側のスコープへと順番に変数が定義されているか探す仕組みのこと
- varキーワードでの変数宣言やfunctionでの関数宣言では巻き上げが発生する
- クロージャーは静的スコープとメモリ管理の仕組みからなる関数が持つ性質

# 関数とthis
https://jsprimer.net/basic/function-this/

- thisキーワードは基本的にはメソッドの中で利用するが、読み取り専用のグローバル変数のようなものでどこにでもかける。
- thisの参照先は主に次の条件によって変化する。
  - 実行コンテキストにおけるthis
  - コンストラクタにおけるthis
  - 関数とメソッドにおけるthis
  - Arrow Functionにおけるthis

## 実行コンテキストとthis

### スクリプトにおけるthis
- 実行コンテキストが"Script"である場合、トップレベルのスコープに書かれたthisはグローバルオブジェクトを参照します。
  - ブラウザのグローバルオブジェクトはwindowオブジェクト

 ### モジュールにおけるthis
- 実行コンテキストが"Module"である場合、そのトップレベルのスコープに書かれたthisは常にundefinedとなります。

## 関数とメソッドにおけるthis
- thisが参照先を決めるルールは、Arrow Functionとそれ以外の関数定義の方法で異なります。

### 関数の種類
```
// `function`キーワードからはじめる関数宣言
function fn1() {}
// `function`を式として扱う関数式
const fn2 = function() {};
// Arrow Functionを使った関数式
const fn3 = () => {};
```

### メソッドの種類
- JavaScriptではオブジェクトのプロパティが関数である場合にそれをメソッドと呼びます。

|  名前  |  関数  |  メソッド  |
| ---- | ---- | ---- |
|  関数宣言(function fn(){})  |  ○  |  ×  |
|  関数式(const fn = function(){})  |  ○  |  ○  |
|  Arrow Function(const fn = () => {})  |  ○  |  ○  |
|  メソッドの短縮記法(const obj = { method(){} })  |  ×  |  ○  |

## Arrow Function以外の関数におけるthis
- Arrow Function以外の関数（メソッドも含む）におけるthisは、実行時に決まる値となります。 言い方を変えるとthisは関数に渡される暗黙的な引数のようなもので、その渡される値は関数を実行するときに決まります。
- 関数におけるthisの基本的な参照先（暗黙的に関数に渡すthisの値）はベースオブジェクトとなります。 ベースオブジェクトとは「メソッドを呼ぶ際に、そのメソッドのドット演算子またはブラケット演算子のひとつ左にあるオブジェクト」のことを言います。
  - ベースオブジェクトがない場合のthisはundefinedとなります。
- thisは関数の定義ではなく呼び出し方で参照する値が異なるので注意

### 関数宣言や関数式におけるthis
- メソッド以外でthisを使う必要はない。

### メソッド呼び出しにおけるthis
- メソッドの場合は、そのメソッドが何かしらのオブジェクトに所属しています。ベースオブジェクトとして、その所属するオブジェクトが取得できます。

## thisが問題となるパターン
- thisには、どの値を参照するかは関数の呼び出し時に決まるという性質に由来したいろいろな問題がある。

### 問題：thisを含むメソッドを変数に代入した場合
- メソッドとして定義した関数も、別の変数に代入すると実行時にはただの関数であるためベースオブジェクトが変わってしまっている。
- 対処法は大きく分けて2つある。
  - メソッドとして定義されている関数はメソッドとして呼ぶと言うこと
  - thisの値を指定して関数を呼べるメソッドで関数を実行する方法（下記対処法参照）
- 基本的には前者のやり方で問題を回避し、どうしてもthisを固定したい場合には後者の方法を取るのが良い。

#### 対処法: call、apply、bindメソッド
- callメソッド
`関数.call(thisの値, ...関数の引数);`

- applyメソッド
`関数.apply(thisの値, [関数の引数1, 関数の引数2]);`

- bindメソッド
`関数.bind(thisの値, ...関数の引数); // => thisや引数がbindされた関数`

### 問題：コールバック関数とthis
- コールバック関数の中でthisを参照すると問題となる場合があります。
- この問題は、メソッドの中でArray#mapメソッドなどのコールバック関数を扱う場合に発生しやすいです。
- Array#mapメソッドに渡しているコールバック関数はcallback()のようにただの関数として呼び出されるため、callback関数のthisはundefinedとなる。

#### 対処法: thisを一時変数へ代入する

#### 対処法: Arrow Functionでコールバック関数を扱う
- Arrow Functionは呼び出し時に暗黙的なthisの値を受け取りません。そのためArrow Function内のthisは、スコープチェーンの仕組みと同様に外側の関数を探索します。これにより、Arrow Functionで定義したコールバック関数は呼び出し方には関係なく、常に外側の関数のthisをそのまま利用します。

## Arrow Functionとthis
- Arrow Functionとそれ以外の関数で大きく違うことは、Arrow Functionはthisを暗黙的な引数として受けつけないということです。
- そのため、Arrow Function内にはthisが定義されていません。このときのthisは外側のスコープ（関数）のthisを参照します。これは、変数におけるスコープチェーンの仕組みと同様で、そのスコープにthisが定義されていない場合には外側のスコープを探索します。
- Arrow Functionにおけるthisは、「Arrow Function自身の外側のスコープに定義されたもっとも近い関数のthisの値」となる。

### メソッドとコールバック関数とArrow Function
- Arrow Functionにおけるthisは呼び出し方の影響を受けません。 つまり、コールバック関数がどのように呼ばれるかという実装についてを考えることなくthisを扱えます。

### Arrow Functionはthisをbindできない
- Arrow Functionで定義した関数ではcall、apply、bindを使ったthisの指定は単に無視されます。 これは、Arrow Functionはthisを持てないためです。

## まとめ
-  メソッド以外においてもthisは評価できますが、実行コンテキストやstrict modeなどによって結果が異なり、混乱の元となります。 そのため、メソッドではない通常の関数においてはthisを使うべきではありません。
- コールバック関数におけるthisはArrow Functionを使うことでわかりやすく解決できます。

# クラス
- クラスとは動作や状態を定義した構造である。 クラスからはインスタンスと呼ばれるオブジェクトを作成できる。インスタンスはクラスに定義した動作を継承し、状態は動作によって変化する。

## クラスの定義
- クラスを定義するにはclass構文を使います。 クラスの定義方法にはクラス宣言文とクラス式があります。

- クラス宣言文によるクラスの定義方法
```
class MyClass {
    constructor() {
        // コンストラクタ関数の処理
        // インスタンス化されるときに自動的に呼び出される
    }
}
```

- クラス式による定義方法。クラスを値として定義する。クラス式ではクラス名を省略できる。
```
const MyClass = class MyClass {
    constructor() {}
};

const AnonymousClass = class {
    constructor() {}
};
```

## クラスのインスタンス化
- クラスはnew演算子でインスタンスであるオブジェクトを作成できます。
```
class MyClass {
}
// `MyClass`をインスタンス化する
const myClass = new MyClass();
// 毎回新しいインスタンス(オブジェクト)を作成する
const myClassAnother = new MyClass();
// それぞれのインスタンスは異なるオブジェクト
console.log(myClass === myClassAnother); // => false
// クラスのインスタンスかどうかは`instanceof`演算子で判定できる
console.log(myClass instanceof MyClass); // => true
console.log(myClassAnother instanceof MyClass); // => true
```

- クラスではインスタンスの初期化処理をコンストラクタ関数で行います。 コンストラクタ関数はnew演算子でインスタンス化する際に自動的に呼び出されます。 コンストラクタ関数内でのthisはこれから新しく作るインスタンスオブジェクトとなります。

```
class Point {
    // 2. コンストラクタ関数の仮引数として`x`には`3`、`y`には`4`が渡る
    constructor(x, y) {
        // 3. インスタンス(`this`)の`x`と`y`プロパティにそれぞれ値を設定する
        this.x = x;
        this.y = y;
        // コンストラクタではreturn文は書かない
    }
}

// 1. コンストラクタを`new`演算子で引数とともに呼び出す
const point = new Point(3, 4);
// 4. `Point`のインスタンスである`point`の`x`と`y`プロパティには初期化された値が入る
console.log(point.x); // => 3
console.log(point.y); // => 4
```

- コンストラクタは初期化処理を書く場所であるため、return文で値を返すべきではありません。
- クラス名は大文字ではじめる

## [コラム] class構文と関数でのクラスの違い
- 関数でクラスのようなものを実装した場合には、関数として呼び出せてしまう問題があります。 

## クラスのプロトタイプメソッドの定義
- class構文ではクラスに対してメソッドを定義できます。メソッドの中からクラスのインスタンスを参照するには、constructorメソッドと同じくthisを使います。
```
class クラス {
    メソッド() {
        // ここでの`this`はベースオブジェクトを参照
    }
}

const インスタンス = new クラス();
// メソッド呼び出しのベースオブジェクト(`this`)は`インスタンス`となる
インスタンス.メソッド();
```

- このようにクラスに対して定義したメソッドは、クラスの各インスタンスから共有されるメソッドとなります。 このインスタンス間で共有されるメソッドのことをプロトタイプメソッドと呼びます。 また、プロトタイプメソッドはインスタンスから呼び出せるメソッドであるためインスタンスメソッドとも呼ばれます。
- プロトタイプメソッドは各インスタンス間で共有されるので、参照先は同じになる。

## クラスのインスタンスに対してメソッドを定義する
- クラスのインスタンスに対して、直接メソッドを定義する方法もあります。これは、コンストラクタ関数内でインスタンスオブジェクトであるthisに対してメソッドを定義するだけです。
- この場合、プロトタイプメソッドとは異なり、インスタンス作成時に毎回関数を新しく定義しているので、各インスタンスからのメソッドの参照先は異なる。（プロトタイプメソッドではメソッドの参照先は同じだった。）
- また、プロトタイプメソッドとは異なり、インスタンスオブジェクトへのメソッド定義はArrow Functionが利用できます。この場合、メソッド内のthisの参照先を固定化できる。

## クラスのアクセッサプロパティの定義
```
class クラス {
    // getter
    get プロパティ名() {
        return 値;
    }
    // setter
    set プロパティ名(仮引数) {
        // setterの処理
    }
}
const インスタンス = new クラス();
インスタンス.プロパティ名; // getterが呼び出される
インスタンス.プロパティ名 = 値; // setterが呼び出される
```

- アクセッサプロパティで実際に読み書きしているプロパティを`_value`などと`_`で開始する習慣がある。構文としての意味はない。

## 静的メソッド
- クラスをインスタンス化せずに利用できる静的メソッド（クラスメソッド）もあります。
- 静的メソッドの定義方法はメソッド名の前に、staticをつけるだけです。

```
class クラス {
    static メソッド() {
        // 静的メソッドの処理
    }
}
// 静的メソッドの呼び出し
クラス.メソッド();
```

- クラスの静的メソッドにおけるthisは、そのクラス自身を参照します。
- 静的メソッドは、クラスのインスタンスを作成する処理やクラスに関係する処理を書くために利用されます。

## 2種類のインスタンスメソッドの定義
- プロトタイプメソッドの定義と、 インスタンスオブジェクトに対するメソッドの定義を同時に使い、1つのクラスに同じ名前でメソッドを2つ定義した場合、下記のようになる。
  - プロトタイプメソッドとインスタンスオブジェクトのメソッドは上書きされずにどちらも定義されている
  - インスタンスオブジェクトのメソッドがプロトタイプオブジェクトのメソッドよりも優先して呼ばれている
- この挙動はプロトタイプオブジェクトと呼ばれる特殊なオブジェクトとプロトタイプチェーンと呼ばれる仕組みで成り立っています。

